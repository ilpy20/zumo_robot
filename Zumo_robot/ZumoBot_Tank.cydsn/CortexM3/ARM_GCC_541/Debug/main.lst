ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"main.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.zmain,"ax",%progbits
  20              		.align	2
  21              		.global	zmain
  22              		.thumb
  23              		.thumb_func
  24              		.type	zmain, %function
  25              	zmain:
  26              	.LFB85:
  27              		.file 1 "main.c"
   1:main.c        **** /**
   2:main.c        **** * @mainpage ZumoBot Project
   3:main.c        **** * @brief    You can make your own ZumoBot with various sensors.
   4:main.c        **** * @details  <br><br>
   5:main.c        ****     <p>
   6:main.c        ****     <B>General</B><br>
   7:main.c        ****     You will use Pololu Zumo Shields for your robot project with CY8CKIT-059(PSoC 5LP) from Cypress
   8:main.c        ****     library has basic methods of various sensors and communications so that you can make what you w
   9:main.c        ****     <br><br>
  10:main.c        ****     </p>
  11:main.c        ****     
  12:main.c        ****     <p>
  13:main.c        ****     <B>Sensors</B><br>
  14:main.c        ****     &nbsp;Included: <br>
  15:main.c        ****         &nbsp;&nbsp;&nbsp;&nbsp;LSM303D: Accelerometer & Magnetometer<br>
  16:main.c        ****         &nbsp;&nbsp;&nbsp;&nbsp;L3GD20H: Gyroscope<br>
  17:main.c        ****         &nbsp;&nbsp;&nbsp;&nbsp;Reflectance sensor<br>
  18:main.c        ****         &nbsp;&nbsp;&nbsp;&nbsp;Motors
  19:main.c        ****     &nbsp;Wii nunchuck<br>
  20:main.c        ****     &nbsp;TSOP-2236: IR Receiver<br>
  21:main.c        ****     &nbsp;HC-SR04: Ultrasonic sensor<br>
  22:main.c        ****     &nbsp;APDS-9301: Ambient light sensor<br>
  23:main.c        ****     &nbsp;IR LED <br><br><br>
  24:main.c        ****     </p>
  25:main.c        ****     
  26:main.c        ****     <p>
  27:main.c        ****     <B>Communication</B><br>
  28:main.c        ****     I2C, UART, Serial<br>
  29:main.c        ****     </p>
  30:main.c        **** */
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 2


  31:main.c        **** 
  32:main.c        **** #include <project.h>
  33:main.c        **** #include <stdio.h>
  34:main.c        **** #include <stdlib.h>
  35:main.c        **** #include "FreeRTOS.h"
  36:main.c        **** #include "task.h"
  37:main.c        **** #include "Motor.h"
  38:main.c        **** #include "Ultra.h"
  39:main.c        **** #include "Nunchuk.h"
  40:main.c        **** #include "Reflectance.h"
  41:main.c        **** #include "Gyro.h"
  42:main.c        **** #include "Accel_magnet.h"
  43:main.c        **** #include "LSM303D.h"
  44:main.c        **** #include "IR.h"
  45:main.c        **** #include "Beep.h"
  46:main.c        **** #include "mqtt_sender.h"
  47:main.c        **** #include <time.h>
  48:main.c        **** #include <sys/time.h>
  49:main.c        **** #include "serial1.h"
  50:main.c        **** #include <unistd.h>
  51:main.c        **** /**
  52:main.c        ****  * @file    main.c
  53:main.c        ****  * @brief   
  54:main.c        ****  * @details  ** Enable global interrupt since Zumo library uses interrupts. **<br>&nbsp;&nbsp;&nbsp
  55:main.c        **** */
  56:main.c        **** 
  57:main.c        **** #if 0
  58:main.c        **** //template
  59:main.c        **** void zmain(void){
  60:main.c        ****     
  61:main.c        ****     while(true)
  62:main.c        ****     {
  63:main.c        ****         BatteryLed_Write(!SW1_Read());
  64:main.c        ****         vTaskDelay(100);
  65:main.c        ****     }
  66:main.c        **** }
  67:main.c        **** #endif
  68:main.c        **** 
  69:main.c        **** #if 0
  70:main.c        **** // Beep light test
  71:main.c        **** void zmain(void)
  72:main.c        **** {
  73:main.c        ****     while(true)
  74:main.c        ****     {
  75:main.c        ****         if ((SW1_Read() == 0)){
  76:main.c        ****             for(int i = 0; i < 3; i++){
  77:main.c        ****                 BatteryLed_Write(1);
  78:main.c        ****                 Beep(750, 30);
  79:main.c        ****                 vTaskDelay(500);
  80:main.c        ****                 BatteryLed_Write(0);
  81:main.c        ****                 vTaskDelay(500);
  82:main.c        ****             }
  83:main.c        ****             for(int i = 0; i<3; i++){
  84:main.c        ****                 BatteryLed_Write(1);
  85:main.c        ****                 Beep(750, 30);
  86:main.c        ****                 vTaskDelay(1000);
  87:main.c        ****                 BatteryLed_Write(0);
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 3


  88:main.c        ****                 vTaskDelay(500);
  89:main.c        ****             }
  90:main.c        ****             for(int i = 0; i < 3; i++){
  91:main.c        ****                 BatteryLed_Write(1);
  92:main.c        ****                 Beep(750, 30);
  93:main.c        ****                 vTaskDelay(500);
  94:main.c        ****                 BatteryLed_Write(0);
  95:main.c        ****                 vTaskDelay(500);
  96:main.c        ****             }
  97:main.c        ****         }
  98:main.c        ****     }
  99:main.c        ****     
 100:main.c        ****     
 101:main.c        ****  }   
 102:main.c        **** #endif
 103:main.c        **** 
 104:main.c        **** #if 0
 105:main.c        **** // Name and age
 106:main.c        **** void zmain(void)
 107:main.c        **** {
 108:main.c        ****     TickType_t start;
 109:main.c        ****     TickType_t end;
 110:main.c        ****     char name[32];
 111:main.c        ****     int age;
 112:main.c        ****     
 113:main.c        ****     
 114:main.c        ****     printf("\n\n");
 115:main.c        ****     
 116:main.c        ****     printf("Enter your name: ");
 117:main.c        ****     //fflush(stdout);
 118:main.c        ****     start = xTaskGetTickCount();
 119:main.c        ****     scanf("%s", name);
 120:main.c        ****     printf("Enter your age: ");
 121:main.c        ****     //fflush(stdout);
 122:main.c        ****     scanf("%d", &age);
 123:main.c        ****     end = xTaskGetTickCount();
 124:main.c        ****     int time_long = end - start;
 125:main.c        ****     //printf("You are [%s], age = %d\n", name, age);
 126:main.c        ****     if (age <= 21){
 127:main.c        ****         if(time_long < 3000){
 128:main.c        ****             printf("\nSuper fast dude!");
 129:main.c        ****         }
 130:main.c        ****         else if((time_long >= 3000)&&(time_long <=5000)){
 131:main.c        ****             printf("\nSo mediocre.");
 132:main.c        ****         }
 133:main.c        ****         else{
 134:main.c        ****             printf("\nMy granny is faster than you!");
 135:main.c        ****         }
 136:main.c        ****     }
 137:main.c        ****     else if((age >= 22)&&(age<=50)){
 138:main.c        ****         if(time_long < 3000){
 139:main.c        ****             printf("\nBe quick or be dead");
 140:main.c        ****         }
 141:main.c        ****         else if((time_long >= 3000)&&(time_long <=5000)){
 142:main.c        ****             printf("\nYou're so average.");
 143:main.c        ****         }
 144:main.c        ****         else{
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 4


 145:main.c        ****             printf("\nHave you been smoking something illegal?");
 146:main.c        ****         }
 147:main.c        ****     }
 148:main.c        ****     else{
 149:main.c        ****         if(time_long <= 3000){
 150:main.c        ****             printf("\nStill going strong");
 151:main.c        ****         }
 152:main.c        ****         else if((time_long >= 4000)&&(time_long <=5000)){
 153:main.c        ****             printf("\nYou are doing ok for your age.");
 154:main.c        ****         }
 155:main.c        ****         else{
 156:main.c        ****             printf("\nDo they still allow you to drive?");
 157:main.c        ****         }
 158:main.c        ****     }
 159:main.c        ****     while(true)
 160:main.c        ****     {
 161:main.c        ****         BatteryLed_Write(!SW1_Read());
 162:main.c        ****         vTaskDelay(100);
 163:main.c        ****     }
 164:main.c        ****  }   
 165:main.c        **** #endif
 166:main.c        **** 
 167:main.c        **** 
 168:main.c        **** #if 0
 169:main.c        **** //battery level//
 170:main.c        **** void zmain(void)
 171:main.c        **** {
 172:main.c        **** 	ADC_Battery_Start();   	 
 173:main.c        **** 
 174:main.c        **** 	int16 adcresult =0;
 175:main.c        **** 	float volts = 0.0;
 176:main.c        **** 
 177:main.c        **** 	printf("\nBoot\n");
 178:main.c        **** 
 179:main.c        **** 	//BatteryLed_Write(1); // Switch led on
 180:main.c        **** 	//BatteryLed_Write(0); // Switch led off
 181:main.c        **** 	//uint8 button;
 182:main.c        **** 	//button = SW1_Read(); // read SW1 on pSoC board
 183:main.c        **** 	// SW1_Read() returns zero when button is pressed
 184:main.c        **** 	// SW1_Read() returns one when button is not pressed
 185:main.c        **** 
 186:main.c        **** 	while(true)
 187:main.c        **** 	{
 188:main.c        ****     	char msg[80];
 189:main.c        ****     	ADC_Battery_StartConvert(); // start sampling
 190:main.c        ****     	if(ADC_Battery_IsEndConversion(ADC_Battery_WAIT_FOR_RESULT)) {   // wait for ADC converted val
 191:main.c        ****         	adcresult = ADC_Battery_GetResult16(); // get the ADC value (0 - 4095)
 192:main.c        ****         	volts=(adcresult*5/4095)*(30/20);
 193:main.c        ****         	// convert value to Volts
 194:main.c        ****         	// you need to implement the conversion
 195:main.c        ****        	 
 196:main.c        ****         	// Print both ADC results and converted value
 197:main.c        ****         	printf("%d %f\r\n",adcresult, volts);
 198:main.c        ****        	 
 199:main.c        ****     	if (volts<4){
 200:main.c        ****         	while(SW1_Read()){
 201:main.c        ****             	BatteryLed_Write(1);
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 5


 202:main.c        ****             	vTaskDelay(500);
 203:main.c        ****             	BatteryLed_Write(0);
 204:main.c        ****             	vTaskDelay(500);
 205:main.c        ****         	}
 206:main.c        ****     	}
 207:main.c        ****     	}
 208:main.c        ****     	vTaskDelay(500);
 209:main.c        **** 	}
 210:main.c        ****  }  
 211:main.c        **** 
 212:main.c        ****    
 213:main.c        **** #endif
 214:main.c        **** 
 215:main.c        **** #if 0
 216:main.c        **** // button
 217:main.c        **** void zmain(void)
 218:main.c        **** {
 219:main.c        ****     while(true) {
 220:main.c        ****         printf("Press button within 5 seconds!\n");
 221:main.c        ****         int i = 50;
 222:main.c        ****         while(i > 0) {
 223:main.c        ****             if(SW1_Read() == 0) {
 224:main.c        ****                 break;
 225:main.c        ****             }
 226:main.c        ****             vTaskDelay(100);
 227:main.c        ****             --i;
 228:main.c        ****         }
 229:main.c        ****         if(i > 0) {
 230:main.c        ****             printf("Good work\n");
 231:main.c        ****             while(SW1_Read() == 0) vTaskDelay(10); // wait until button is released
 232:main.c        ****         }
 233:main.c        ****         else {
 234:main.c        ****             printf("You didn't press the button\n");
 235:main.c        ****         }
 236:main.c        ****     }
 237:main.c        **** }
 238:main.c        **** #endif
 239:main.c        **** 
 240:main.c        **** #if 0
 241:main.c        **** // button
 242:main.c        **** void zmain(void)
 243:main.c        **** {
 244:main.c        ****     printf("\nBoot\n");
 245:main.c        **** 
 246:main.c        ****     //BatteryLed_Write(1); // Switch led on 
 247:main.c        ****     BatteryLed_Write(0); // Switch led off 
 248:main.c        ****     
 249:main.c        ****     //uint8 button;
 250:main.c        ****     //button = SW1_Read(); // read SW1 on pSoC board
 251:main.c        ****     // SW1_Read() returns zero when button is pressed
 252:main.c        ****     // SW1_Read() returns one when button is not pressed
 253:main.c        ****     
 254:main.c        ****     bool led = false;
 255:main.c        ****     
 256:main.c        ****     while(true)
 257:main.c        ****     {
 258:main.c        ****         // toggle led state when button is pressed
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 6


 259:main.c        ****         if(SW1_Read() == 0) {
 260:main.c        ****             led = !led;
 261:main.c        ****             BatteryLed_Write(led);
 262:main.c        ****             if(led) printf("Led is ON\n");
 263:main.c        ****             else printf("Led is OFF\n");
 264:main.c        ****             Beep(1000, 150);
 265:main.c        ****             while(SW1_Read() == 0) vTaskDelay(10); // wait while button is being pressed
 266:main.c        ****         }        
 267:main.c        ****     }
 268:main.c        ****  }   
 269:main.c        **** #endif
 270:main.c        **** 
 271:main.c        **** #if 0
 272:main.c        ****     void tankturn_left(uint8 speed_left, uint8 speed_right, int delay);
 273:main.c        ****     
 274:main.c        **** void zmain(void)
 275:main.c        **** {
 276:main.c        ****     Ultra_Start();
 277:main.c        ****     motor_start(0,0);
 278:main.c        ****     motor_forward(0,0);
 279:main.c        ****     
 280:main.c        ****     vTaskDelay(3000);
 281:main.c        ****     
 282:main.c        ****     while(true){
 283:main.c        ****     int distance = Ultra_GetDistance();
 284:main.c        ****     
 285:main.c        ****     if(distance <= 10 && distance !=0){
 286:main.c        ****         motor_backward(50,500);
 287:main.c        ****         Beep(150, 200);
 288:main.c        ****         motor_turn(150,150, 500);
 289:main.c        ****         motor_forward(0,0);
 290:main.c        ****      }
 291:main.c        ****     motor_turn(200,100,50);
 292:main.c        ****     }   
 293:main.c        **** }
 294:main.c        **** #endif
 295:main.c        **** 
 296:main.c        **** #if 0
 297:main.c        **** //ultrasonic sensor//
 298:main.c        **** void zmain(void)
 299:main.c        **** {
 300:main.c        ****     Ultra_Start();                          // Ultra Sonic Start function
 301:main.c        ****     
 302:main.c        ****     while(true) {
 303:main.c        ****         int d = Ultra_GetDistance();
 304:main.c        ****         // Print the detected distance (centimeters)
 305:main.c        ****         printf("distance = %d\r\n", d);
 306:main.c        ****         vTaskDelay(200);
 307:main.c        ****     }
 308:main.c        **** }   
 309:main.c        **** #endif
 310:main.c        **** 
 311:main.c        **** #if 0
 312:main.c        **** //IR receiverm - how to wait for IR remote commands
 313:main.c        **** void zmain(void)
 314:main.c        **** {
 315:main.c        ****     uint8_t button_;
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 7


 316:main.c        ****     printf("\nStart\n");
 317:main.c        ****     
 318:main.c        ****     while(true){
 319:main.c        ****         button_ = SW1_Read();
 320:main.c        ****         if(button_==0){
 321:main.c        ****             IR_Start();
 322:main.c        ****             printf("\n\nIR test\n");
 323:main.c        ****             struct sensors_ ref;
 324:main.c        ****             struct sensors_ dig;
 325:main.c        ****             bool led = false,loop = true, startline= true;
 326:main.c        ****             int count =0;
 327:main.c        ****             motor_start();              // enable motor controller 
 328:main.c        ****             IR_flush(); // clear IR receive buffer
 329:main.c        ****             printf("Buffer cleared\n");
 330:main.c        ****             
 331:main.c        ****             reflectance_start();
 332:main.c        ****             reflectance_set_threshold(9000, 9000, 11000, 11000, 9000, 9000); // set center sensor t
 333:main.c        ****             vTaskDelay(200);
 334:main.c        ****                 while(startline){
 335:main.c        ****                     // read raw sensor values
 336:main.c        ****                     reflectance_read(&ref);
 337:main.c        ****                     reflectance_digital(&dig); 
 338:main.c        ****                     if(dig.l3 != 1 && dig.r3 != 1){
 339:main.c        ****                         motor_turn(50,50,50);       // motor forward
 340:main.c        ****                         Beep(60,80);
 341:main.c        ****                     }
 342:main.c        ****                     else{
 343:main.c        ****                         motor_forward(0,0);       // Stop motors
 344:main.c        ****                         startline = false;
 345:main.c        ****                     }
 346:main.c        ****                 }
 347:main.c        ****             IR_wait();  // wait for IR command
 348:main.c        ****             led = !led;
 349:main.c        ****             BatteryLed_Write(led);   
 350:main.c        ****             
 351:main.c        ****             // Toggle led when IR signal is received
 352:main.c        ****             while(loop)
 353:main.c        ****             {   
 354:main.c        ****                 if(led){
 355:main.c        ****                     // read raw sensor values
 356:main.c        ****                     reflectance_read(&ref);
 357:main.c        ****                     reflectance_digital(&dig); 
 358:main.c        ****                     
 359:main.c        ****                     if(dig.l3 == 1 && dig.r3 == 1 ){
 360:main.c        ****                         motor_turn(50,50,50);       // motor forward
 361:main.c        ****                         vTaskDelay(50);
 362:main.c        ****                         count++;
 363:main.c        ****                         printf("count %d \n",count);
 364:main.c        ****                         if(count >= 7){
 365:main.c        ****                             motor_forward(0,0);       // Stop motors
 366:main.c        ****                             loop = false;
 367:main.c        ****                         }
 368:main.c        ****                     }
 369:main.c        ****                     else{
 370:main.c        ****                          motor_turn(50,50,50);       // motor forward
 371:main.c        ****                         Beep(100,100);
 372:main.c        ****                     }
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 8


 373:main.c        ****                 }
 374:main.c        ****                 else {
 375:main.c        ****                     printf("Led is OFF\n");
 376:main.c        ****                     loop = false;
 377:main.c        ****                 }
 378:main.c        ****                
 379:main.c        ****             }    
 380:main.c        ****         }
 381:main.c        ****     }
 382:main.c        ****  }   
 383:main.c        **** #endif
 384:main.c        **** 
 385:main.c        **** 
 386:main.c        **** #if 0
 387:main.c        **** //IR receiverm - how to wait for IR remote commands
 388:main.c        **** void zmain(void)
 389:main.c        **** {
 390:main.c        ****     uint8_t button_;
 391:main.c        ****     printf("\nStart\n");
 392:main.c        ****     
 393:main.c        ****     while(true){
 394:main.c        ****         button_ = SW1_Read();
 395:main.c        ****         if(button_==0){
 396:main.c        ****             IR_Start();
 397:main.c        ****             printf("\n\nIR test\n");
 398:main.c        ****             struct sensors_ ref;
 399:main.c        ****             struct sensors_ dig;
 400:main.c        ****             bool led = false,loop = true, startline= true/*, crossline= true*/;
 401:main.c        ****             int count =0;
 402:main.c        ****             motor_start();              // enable motor controller 
 403:main.c        ****             IR_flush(); // clear IR receive buffer
 404:main.c        ****             printf("Buffer cleared\n");
 405:main.c        ****             
 406:main.c        ****             reflectance_start();
 407:main.c        ****             reflectance_set_threshold(9000, 9000, 11000, 11000, 9000, 9000); // set center sensor t
 408:main.c        ****             vTaskDelay(200);
 409:main.c        ****                 while(startline){
 410:main.c        ****                     // read raw sensor values
 411:main.c        ****                     reflectance_read(&ref);
 412:main.c        ****                     reflectance_digital(&dig); 
 413:main.c        ****                     if(dig.l3 != 1 && dig.r3 != 1){
 414:main.c        ****                         motor_turn(50,50,0);       // motor forward
 415:main.c        ****                         //Beep(60,80);
 416:main.c        ****                     }
 417:main.c        ****                     else{
 418:main.c        ****                         motor_forward(0,0);       // Stop motors
 419:main.c        ****                         startline = false;
 420:main.c        ****                     }
 421:main.c        ****                 }
 422:main.c        ****             IR_wait();  // wait for IR command
 423:main.c        ****             led = !led;
 424:main.c        ****             BatteryLed_Write(led);   
 425:main.c        ****             
 426:main.c        ****             // Toggle led when IR signal is received
 427:main.c        ****             while(loop)
 428:main.c        ****             {   
 429:main.c        ****                 if(led){
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 9


 430:main.c        ****                     //do {
 431:main.c        ****                         // read raw sensor values
 432:main.c        ****                     //reflectance_read(&ref);
 433:main.c        ****                     reflectance_digital(&dig); 
 434:main.c        ****                     
 435:main.c        ****                    
 436:main.c        ****                         /*if(dig.l3 == 1 && dig.l2 == 1 && dig.l1 == 1 && dig.r3 == 1 && dig.r2 == 
 437:main.c        ****                             motor_forward(0,0);
 438:main.c        ****                             count++;
 439:main.c        ****                             if(count==1){
 440:main.c        ****                                 motor_turn(50,50,50);       // motor forward
 441:main.c        ****                             }
 442:main.c        ****                             if (count==2){
 443:main.c        ****                                 motor_turn_left(10,100,500);
 444:main.c        ****                             }
 445:main.c        ****                             if (count<=4){
 446:main.c        ****                                 motor_turn_right(100,10,500);
 447:main.c        ****                             }
 448:main.c        ****                             if (count==5){
 449:main.c        ****                                 motor_forward(0,0);       // Stop motors
 450:main.c        ****                                 led = false;
 451:main.c        ****                                 BatteryLed_Write(led);
 452:main.c        ****                             }
 453:main.c        ****                         } */
 454:main.c        ****                         if(dig.r2 == 1 && dig.r1 == 1){
 455:main.c        ****                             //count++;
 456:main.c        ****                             motor_turn(100,10,0);       // motor turn left
 457:main.c        ****                             //Beep(20,20);
 458:main.c        ****                             vTaskDelay(0);
 459:main.c        ****                             
 460:main.c        ****                             printf("count %d \n",count);
 461:main.c        ****                         }
 462:main.c        ****                         if(dig.l2 == 1 && dig.l1 == 1){
 463:main.c        ****                             //count++;
 464:main.c        ****                             motor_turn(10,100,0);       // motor turn right
 465:main.c        ****                            // Beep(20,20);
 466:main.c        ****                             vTaskDelay(0);
 467:main.c        ****                             
 468:main.c        ****                             printf("count %d \n",count);
 469:main.c        ****                         }
 470:main.c        ****                        // printf("count %d \n",count);
 471:main.c        ****                         if (dig.l1 == 1 && dig.r1 == 1){
 472:main.c        ****                             
 473:main.c        ****                             motor_turn(50,50,0);       // motor forward
 474:main.c        ****                             vTaskDelay(0);
 475:main.c        ****                             //Beep(50,50);
 476:main.c        ****                             //count++;
 477:main.c        ****                             printf("count %d \n",count);
 478:main.c        ****                         }
 479:main.c        ****                    
 480:main.c        ****                 }
 481:main.c        ****                 else {
 482:main.c        ****                     printf("Led is OFF\n");
 483:main.c        ****                     loop = false;
 484:main.c        ****                 }
 485:main.c        ****                
 486:main.c        ****             }    
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 10


 487:main.c        ****         }
 488:main.c        ****     }
 489:main.c        ****  }  
 490:main.c        **** #endif
 491:main.c        **** 
 492:main.c        **** #if 0
 493:main.c        **** //IR receiverm - how to wait for IR remote commands
 494:main.c        **** void zmain(void)
 495:main.c        **** {
 496:main.c        ****     //IR receiverm - how to wait for IR remote commands
 497:main.c        **** void zmain(void);
 498:main.c        **** 
 499:main.c        ****     uint8_t button_;
 500:main.c        ****     printf("\nStart\n");
 501:main.c        **** 
 502:main.c        ****     while(true){
 503:main.c        ****         button_ = SW1_Read();
 504:main.c        ****         if(button_==0){
 505:main.c        ****             IR_Start();
 506:main.c        ****             printf("\n\nIR test\n");
 507:main.c        ****             struct sensors_ ref;
 508:main.c        ****             struct sensors_ dig;
 509:main.c        ****             bool led = false,loop = true, startline= true;
 510:main.c        ****             int count =0;
 511:main.c        ****             motor_start();              // enable motor controller 
 512:main.c        ****             IR_flush(); // clear IR receive buffer
 513:main.c        ****             printf("Buffer cleared\n");
 514:main.c        **** 
 515:main.c        ****             reflectance_start();
 516:main.c        ****             reflectance_set_threshold(9000, 9000, 11000, 11000, 9000, 9000); // set center sensor t
 517:main.c        ****             vTaskDelay(200);
 518:main.c        ****                 while(startline){
 519:main.c        ****                     // read raw sensor values
 520:main.c        ****                     reflectance_read(&ref);
 521:main.c        ****                     reflectance_digital(&dig); 
 522:main.c        ****                     if(dig.l3 != 1 && dig.r3 != 1){
 523:main.c        ****                         motor_turn(50,50,50);       // motor forward
 524:main.c        ****                         Beep(60,80);
 525:main.c        ****                     }
 526:main.c        **** 
 527:main.c        ****                     else{
 528:main.c        ****                         motor_forward(0,0);       // Stop motors
 529:main.c        ****                         startline = false;
 530:main.c        ****                     }
 531:main.c        ****                 }
 532:main.c        ****             IR_wait();  // wait for IR command
 533:main.c        ****             led = !led;
 534:main.c        ****             BatteryLed_Write(led);   
 535:main.c        **** 
 536:main.c        ****             // Toggle led when IR signal is received
 537:main.c        ****             while(loop)
 538:main.c        ****             {   
 539:main.c        ****                 if(led){
 540:main.c        ****                     // read raw sensor values
 541:main.c        ****                     reflectance_read(&ref);
 542:main.c        ****                     reflectance_digital(&dig); 
 543:main.c        **** 
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 11


 544:main.c        ****                     if(dig.l3 == 1 && dig.r3 == 1 && dig.l1 == 1 && dig.r1 == 1){
 545:main.c        ****                         count++;
 546:main.c        ****                         printf("\nStart\n");
 547:main.c        ****                         printf("count %d \n",count);
 548:main.c        **** 
 549:main.c        **** 
 550:main.c        ****                         while (dig.r3 == 1 && dig.l3 == 1){
 551:main.c        ****                          motor_turn(50,49,0);
 552:main.c        ****                         reflectance_digital(&dig);
 553:main.c        ****                         }
 554:main.c        ****                         if(count >= 2){
 555:main.c        ****                             motor_forward(210,0);       // Stop motors
 556:main.c        ****                         }
 557:main.c        ****                     }
 558:main.c        **** 
 559:main.c        ****                     else if (dig.l1 == 1 && dig.r1 == 1){
 560:main.c        ****                         motor_turn(210,210,0);   //goes forward lul
 561:main.c        ****                         printf("%5d %5d", ref.l1, ref.r1);
 562:main.c        ****                     }
 563:main.c        ****                     else if (dig.l1 == 0 && dig.r1 == 1){
 564:main.c        ****                         motor_turn(210,0,0);  //turns right lul
 565:main.c        ****                         printf("%5d %5d", ref.l1, ref.r1);
 566:main.c        ****                     }
 567:main.c        ****                     else if (dig.l1 == 1 && dig.r1 == 0){
 568:main.c        ****                         motor_turn(0,210,0);   ///should turn left, right lul??   
 569:main.c        ****                         printf("%5d %5d", ref.l1, ref.r1);
 570:main.c        ****                     }
 571:main.c        ****                     else if (dig.l3 == 1 && dig.r3 == 1 && dig.l1 == 1 && dig.r1 == 1 && dig.l2 == 
 572:main.c        ****                         motor_turn(0,0,100000);   ///should stop, right lul??   
 573:main.c        **** 
 574:main.c        **** 
 575:main.c        ****                         }
 576:main.c        ****                     }
 577:main.c        ****                 }
 578:main.c        **** 
 579:main.c        **** 
 580:main.c        ****             }    
 581:main.c        ****         }
 582:main.c        **** 
 583:main.c        **** }   
 584:main.c        **** #endif
 585:main.c        **** 
 586:main.c        **** 
 587:main.c        **** #if 0
 588:main.c        **** //reflectance
 589:main.c        **** void zmain(void)
 590:main.c        **** {
 591:main.c        ****     struct sensors_ ref;
 592:main.c        ****     struct sensors_ dig;
 593:main.c        **** 
 594:main.c        ****     reflectance_start();
 595:main.c        ****     reflectance_set_threshold(9000, 9000, 11000, 11000, 9000, 9000); // set center sensor threshold
 596:main.c        ****     
 597:main.c        **** 
 598:main.c        ****     while(true)
 599:main.c        ****     {
 600:main.c        ****         // read raw sensor values
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 12


 601:main.c        ****         reflectance_read(&ref);
 602:main.c        ****         // print out each period of reflectance sensors
 603:main.c        ****         printf("%5d %5d %5d %5d %5d %5d\r\n", ref.l3, ref.l2, ref.l1, ref.r1, ref.r2, ref.r3);     
 604:main.c        ****         
 605:main.c        ****         // read digital values that are based on threshold. 0 = white, 1 = black
 606:main.c        ****         // when blackness value is over threshold the sensors reads 1, otherwise 0
 607:main.c        ****         reflectance_digital(&dig); 
 608:main.c        ****         //print out 0 or 1 according to results of reflectance period
 609:main.c        ****         printf("%5d %5d %5d %5d %5d %5d \r\n", dig.l3, dig.l2, dig.l1, dig.r1, dig.r2, dig.r3);    
 610:main.c        ****         
 611:main.c        ****         vTaskDelay(200);
 612:main.c        ****     }
 613:main.c        **** }   
 614:main.c        **** #endif
 615:main.c        **** 
 616:main.c        **** 
 617:main.c        **** #if 0
 618:main.c        **** //motor
 619:main.c        **** void zmain(void)
 620:main.c        **** {
 621:main.c        ****     struct sensors_ ref;
 622:main.c        ****     struct sensors_ dig;
 623:main.c        **** 
 624:main.c        ****     reflectance_start();
 625:main.c        ****     reflectance_set_threshold(9000, 9000, 11000, 11000, 9000, 9000); // set center sensor threshold
 626:main.c        ****     
 627:main.c        ****     reflectance_digital(&dig);
 628:main.c        ****     
 629:main.c        ****     motor_start();              // enable motor controller
 630:main.c        ****     motor_forward(0,0);         // set speed to zero to stop motors
 631:main.c        **** 
 632:main.c        ****     vTaskDelay(3000);
 633:main.c        ****     
 634:main.c        ****     if(dig.l3, dig.l2, dig.l1){
 635:main.c        ****         
 636:main.c        ****     }
 637:main.c        ****     motor_forward(100,2000);     // moving forward
 638:main.c        ****     motor_turn(200,50,2000);     // turn
 639:main.c        ****     motor_turn(50,200,2000);     // turn
 640:main.c        ****     motor_backward(100,2000);    // moving backward
 641:main.c        ****      
 642:main.c        ****     motor_forward(0,0);         // stop motors
 643:main.c        **** 
 644:main.c        ****     motor_stop();               // disable motor controller
 645:main.c        ****     
 646:main.c        ****     while(true)
 647:main.c        ****     {
 648:main.c        ****         vTaskDelay(100);
 649:main.c        ****     }
 650:main.c        **** }
 651:main.c        **** #endif
 652:main.c        **** 
 653:main.c        **** #if 0
 654:main.c        **** /* Example of how to use te Accelerometer!!!*/
 655:main.c        **** void zmain(void)
 656:main.c        **** {
 657:main.c        ****     struct accData_ data;
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 13


 658:main.c        ****     
 659:main.c        ****     printf("Accelerometer test...\n");
 660:main.c        **** 
 661:main.c        ****     if(!LSM303D_Start()){
 662:main.c        ****         printf("LSM303D failed to initialize!!! Program is Ending!!!\n");
 663:main.c        ****         vTaskSuspend(NULL);
 664:main.c        ****     }
 665:main.c        ****     else {
 666:main.c        ****         printf("Device Ok...\n");
 667:main.c        ****     }
 668:main.c        ****     motor_start();              // enable motor controller
 669:main.c        ****     motor_forward(0,0);
 670:main.c        ****     srand(time(NULL));   // Initialization, should only be called once.
 671:main.c        ****     int r=0, counter=0;
 672:main.c        ****     while(true)
 673:main.c        ****     {
 674:main.c        ****         LSM303D_Read_Acc(&data);
 675:main.c        ****        
 676:main.c        ****         motor_forward(200,20);
 677:main.c        ****         //vTaskDelay(200);
 678:main.c        ****         if (counter == 0) r = rand() % 2;
 679:main.c        ****         if (counter > 19){
 680:main.c        ****             counter = 0;
 681:main.c        ****             r = rand() % 2;
 682:main.c        ****         }// Returns a pseudo-random integer between 0 and RAND_MAX.
 683:main.c        ****             if(r == 0){
 684:main.c        ****                 motor_turn(200,50,5);
 685:main.c        ****                 vTaskDelay(0);
 686:main.c        ****                 //motor_forward(0,0);
 687:main.c        ****             }
 688:main.c        ****             else if(r == 1){
 689:main.c        ****                 motor_turn(50,200,5);
 690:main.c        ****                 vTaskDelay(0);
 691:main.c        ****                 //motor_forward(0,0);
 692:main.c        ****             }
 693:main.c        ****             else {
 694:main.c        ****                 motor_forward(200,20);
 695:main.c        ****                 vTaskDelay(0);
 696:main.c        ****             }
 697:main.c        ****         LSM303D_Read_Acc(&data);
 698:main.c        ****         if((data.accX<-4000)){
 699:main.c        ****             int r = rand() % 2;      // Returns a pseudo-random integer between 0 and RAND_MAX.
 700:main.c        ****             if(r == 0){
 701:main.c        ****                 motor_backward(80,50);
 702:main.c        ****                 motor_turn(200,50,500);
 703:main.c        ****                 vTaskDelay(0);
 704:main.c        ****                 //motor_forward(0,0);
 705:main.c        ****             }
 706:main.c        ****             else{
 707:main.c        ****                 motor_backward(80,50);
 708:main.c        ****                 motor_turn(50,200,500);
 709:main.c        ****                 vTaskDelay(0);
 710:main.c        ****                 //motor_forward(0,0);
 711:main.c        ****             }
 712:main.c        ****             motor_forward(100,100);
 713:main.c        ****         }
 714:main.c        ****         counter++;
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 14


 715:main.c        ****         printf("%8d %8d %8d\n",data.accX, data.accY, data.accZ);
 716:main.c        ****         vTaskDelay(0);
 717:main.c        ****     }
 718:main.c        ****  }   
 719:main.c        **** #endif    
 720:main.c        **** 
 721:main.c        **** #if 0
 722:main.c        **** // MQTT test
 723:main.c        **** void zmain(void)
 724:main.c        **** {
 725:main.c        ****     int ctr = 0;
 726:main.c        **** 
 727:main.c        ****     printf("\nBoot\n");
 728:main.c        ****     send_mqtt("Zumo01/debug", "Boot");
 729:main.c        **** 
 730:main.c        ****     //BatteryLed_Write(1); // Switch led on 
 731:main.c        ****     BatteryLed_Write(0); // Switch led off 
 732:main.c        **** 
 733:main.c        ****     while(true)
 734:main.c        ****     {
 735:main.c        ****         printf("Ctr: %d, Button: %d\n", ctr, SW1_Read());
 736:main.c        ****         print_mqtt("Zumo01/debug", "Ctr: %d, Button: %d", ctr, SW1_Read());
 737:main.c        **** 
 738:main.c        ****         vTaskDelay(1000);
 739:main.c        ****         ctr++;
 740:main.c        ****     }
 741:main.c        ****  }   
 742:main.c        **** #endif
 743:main.c        **** 
 744:main.c        **** #if 1
 745:main.c        **** 
 746:main.c        ****     
 747:main.c        **** void zmain(void)
 748:main.c        **** {
  28              		.loc 1 748 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32 0000 08B5     		push	{r3, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 3, -8
  35              		.cfi_offset 14, -4
 749:main.c        ****     Ultra_Start();
  36              		.loc 1 749 0
  37 0002 FFF7FEFF 		bl	Ultra_Start
  38              	.LVL0:
 750:main.c        ****     motor_start(0,0);
  39              		.loc 1 750 0
  40 0006 0021     		movs	r1, #0
  41 0008 0846     		mov	r0, r1
  42 000a FFF7FEFF 		bl	motor_start
  43              	.LVL1:
 751:main.c        ****     motor_forward(0,0);
  44              		.loc 1 751 0
  45 000e 0021     		movs	r1, #0
  46 0010 0846     		mov	r0, r1
  47 0012 FFF7FEFF 		bl	motor_forward
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 15


  48              	.LVL2:
 752:main.c        ****     
 753:main.c        ****     vTaskDelay(3000);
  49              		.loc 1 753 0
  50 0016 40F6B830 		movw	r0, #3000
  51 001a FFF7FEFF 		bl	vTaskDelay
  52              	.LVL3:
  53              	.L2:
  54              	.LBB2:
 754:main.c        ****     
 755:main.c        ****     while(true){
 756:main.c        ****         int distance = Ultra_GetDistance();
  55              		.loc 1 756 0
  56 001e FFF7FEFF 		bl	Ultra_GetDistance
  57              	.LVL4:
 757:main.c        ****     
 758:main.c        ****         if(distance <= 10 && distance !=0){
  58              		.loc 1 758 0
  59 0022 0A28     		cmp	r0, #10
  60 0024 FBDC     		bgt	.L2
  61              		.loc 1 758 0 is_stmt 0 discriminator 1
  62 0026 0028     		cmp	r0, #0
  63 0028 F9D0     		beq	.L2
  64              	.LBB3:
 759:main.c        ****             int r = rand() % 2;      // Returns a pseudo-random integer between 0 and RAND_MAX.
  65              		.loc 1 759 0 is_stmt 1
  66 002a FFF7FEFF 		bl	rand
  67              	.LVL5:
  68 002e 144B     		ldr	r3, .L8
  69 0030 1840     		ands	r0, r0, r3
  70 0032 03D5     		bpl	.L4
  71 0034 0138     		subs	r0, r0, #1
  72 0036 60F00100 		orn	r0, r0, #1
  73 003a 0130     		adds	r0, r0, #1
  74              	.L4:
  75              	.LVL6:
 760:main.c        ****             if(r == 0){
  76              		.loc 1 760 0
  77 003c 68B9     		cbnz	r0, .L5
 761:main.c        ****                 motor_turn(50,200,500);
  78              		.loc 1 761 0
  79 003e 4FF4FA72 		mov	r2, #500
  80 0042 C821     		movs	r1, #200
  81 0044 3220     		movs	r0, #50
  82              	.LVL7:
  83 0046 FFF7FEFF 		bl	motor_turn
  84              	.LVL8:
 762:main.c        ****                 vTaskDelay(0);
  85              		.loc 1 762 0
  86 004a 0020     		movs	r0, #0
  87 004c FFF7FEFF 		bl	vTaskDelay
  88              	.LVL9:
 763:main.c        ****                 print_mqtt("Zumo006/turn", "left");
  89              		.loc 1 763 0
  90 0050 0C49     		ldr	r1, .L8+4
  91 0052 0D48     		ldr	r0, .L8+8
  92 0054 FFF7FEFF 		bl	print_mqtt
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 16


  93              	.LVL10:
  94 0058 0CE0     		b	.L6
  95              	.LVL11:
  96              	.L5:
 764:main.c        ****                 //motor_forward(0,0);
 765:main.c        ****             }
 766:main.c        ****             else{
 767:main.c        ****                 motor_turn(200,50,500);
  97              		.loc 1 767 0
  98 005a 4FF4FA72 		mov	r2, #500
  99 005e 3221     		movs	r1, #50
 100 0060 C820     		movs	r0, #200
 101              	.LVL12:
 102 0062 FFF7FEFF 		bl	motor_turn
 103              	.LVL13:
 768:main.c        ****                 vTaskDelay(0);
 104              		.loc 1 768 0
 105 0066 0020     		movs	r0, #0
 106 0068 FFF7FEFF 		bl	vTaskDelay
 107              	.LVL14:
 769:main.c        ****                 print_mqtt("Zumo006/turn", "right");
 108              		.loc 1 769 0
 109 006c 0749     		ldr	r1, .L8+12
 110 006e 0648     		ldr	r0, .L8+8
 111 0070 FFF7FEFF 		bl	print_mqtt
 112              	.LVL15:
 113              	.L6:
 770:main.c        ****                 //motor_forward(0,0);
 771:main.c        ****             }
 772:main.c        ****             motor_forward(100,100);
 114              		.loc 1 772 0
 115 0074 6421     		movs	r1, #100
 116 0076 0846     		mov	r0, r1
 117 0078 FFF7FEFF 		bl	motor_forward
 118              	.LVL16:
 119 007c CFE7     		b	.L2
 120              	.L9:
 121 007e 00BF     		.align	2
 122              	.L8:
 123 0080 01000080 		.word	-2147483647
 124 0084 00000000 		.word	.LC0
 125 0088 08000000 		.word	.LC1
 126 008c 18000000 		.word	.LC2
 127              	.LBE3:
 128              	.LBE2:
 129              		.cfi_endproc
 130              	.LFE85:
 131              		.size	zmain, .-zmain
 132              		.section	.rodata.str1.4,"aMS",%progbits,1
 133              		.align	2
 134              	.LC0:
 135 0000 6C656674 		.ascii	"left\000"
 135      00
 136 0005 000000   		.space	3
 137              	.LC1:
 138 0008 5A756D6F 		.ascii	"Zumo006/turn\000"
 138      3030362F 
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 17


 138      7475726E 
 138      00
 139 0015 000000   		.space	3
 140              	.LC2:
 141 0018 72696768 		.ascii	"right\000"
 141      7400
 142              		.text
 143              	.Letext0:
 144              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 145              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 146              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 147              		.file 5 ".\\ZumoLibrary/Motor.h"
 148              		.file 6 "..\\FreeRTOS\\Source\\include/task.h"
 149              		.file 7 ".\\ZumoLibrary/mqtt_sender.h"
 150              		.file 8 ".\\ZumoLibrary/Ultra.h"
 151              		.file 9 "Generated_Source\\PSoC5/core_cm3.h"
 152              		.section	.debug_info,"",%progbits
 153              	.Ldebug_info0:
 154 0000 76020000 		.4byte	0x276
 155 0004 0400     		.2byte	0x4
 156 0006 00000000 		.4byte	.Ldebug_abbrev0
 157 000a 04       		.byte	0x4
 158 000b 01       		.uleb128 0x1
 159 000c 3E000000 		.4byte	.LASF25
 160 0010 0C       		.byte	0xc
 161 0011 C2010000 		.4byte	.LASF26
 162 0015 5D010000 		.4byte	.LASF27
 163 0019 00000000 		.4byte	.Ldebug_ranges0+0
 164 001d 00000000 		.4byte	0
 165 0021 00000000 		.4byte	.Ldebug_line0
 166 0025 02       		.uleb128 0x2
 167 0026 01       		.byte	0x1
 168 0027 06       		.byte	0x6
 169 0028 24000000 		.4byte	.LASF0
 170 002c 02       		.uleb128 0x2
 171 002d 01       		.byte	0x1
 172 002e 08       		.byte	0x8
 173 002f 30000000 		.4byte	.LASF1
 174 0033 02       		.uleb128 0x2
 175 0034 02       		.byte	0x2
 176 0035 05       		.byte	0x5
 177 0036 CE010000 		.4byte	.LASF2
 178 003a 02       		.uleb128 0x2
 179 003b 02       		.byte	0x2
 180 003c 07       		.byte	0x7
 181 003d DE000000 		.4byte	.LASF3
 182 0041 03       		.uleb128 0x3
 183 0042 00000000 		.4byte	.LASF9
 184 0046 02       		.byte	0x2
 185 0047 3F       		.byte	0x3f
 186 0048 4C000000 		.4byte	0x4c
 187 004c 02       		.uleb128 0x2
 188 004d 04       		.byte	0x4
 189 004e 05       		.byte	0x5
 190 004f D8010000 		.4byte	.LASF4
 191 0053 02       		.uleb128 0x2
 192 0054 04       		.byte	0x4
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 18


 193 0055 07       		.byte	0x7
 194 0056 CC000000 		.4byte	.LASF5
 195 005a 02       		.uleb128 0x2
 196 005b 08       		.byte	0x8
 197 005c 05       		.byte	0x5
 198 005d B4010000 		.4byte	.LASF6
 199 0061 02       		.uleb128 0x2
 200 0062 08       		.byte	0x8
 201 0063 07       		.byte	0x7
 202 0064 32010000 		.4byte	.LASF7
 203 0068 04       		.uleb128 0x4
 204 0069 04       		.byte	0x4
 205 006a 05       		.byte	0x5
 206 006b 696E7400 		.ascii	"int\000"
 207 006f 02       		.uleb128 0x2
 208 0070 04       		.byte	0x4
 209 0071 07       		.byte	0x7
 210 0072 25010000 		.4byte	.LASF8
 211 0076 03       		.uleb128 0x3
 212 0077 55010000 		.4byte	.LASF10
 213 007b 03       		.byte	0x3
 214 007c 2C       		.byte	0x2c
 215 007d 41000000 		.4byte	0x41
 216 0081 02       		.uleb128 0x2
 217 0082 04       		.byte	0x4
 218 0083 04       		.byte	0x4
 219 0084 1E000000 		.4byte	.LASF11
 220 0088 02       		.uleb128 0x2
 221 0089 08       		.byte	0x8
 222 008a 04       		.byte	0x4
 223 008b 0C010000 		.4byte	.LASF12
 224 008f 02       		.uleb128 0x2
 225 0090 01       		.byte	0x1
 226 0091 08       		.byte	0x8
 227 0092 C9010000 		.4byte	.LASF13
 228 0096 02       		.uleb128 0x2
 229 0097 08       		.byte	0x8
 230 0098 04       		.byte	0x4
 231 0099 EC010000 		.4byte	.LASF14
 232 009d 02       		.uleb128 0x2
 233 009e 04       		.byte	0x4
 234 009f 07       		.byte	0x7
 235 00a0 AB010000 		.4byte	.LASF15
 236 00a4 05       		.uleb128 0x5
 237 00a5 1F010000 		.4byte	.LASF28
 238 00a9 01       		.byte	0x1
 239 00aa EB02     		.2byte	0x2eb
 240 00ac 00000000 		.4byte	.LFB85
 241 00b0 90000000 		.4byte	.LFE85-.LFB85
 242 00b4 01       		.uleb128 0x1
 243 00b5 9C       		.byte	0x9c
 244 00b6 0F020000 		.4byte	0x20f
 245 00ba 06       		.uleb128 0x6
 246 00bb 1E000000 		.4byte	.LBB2
 247 00bf 72000000 		.4byte	.LBE2-.LBB2
 248 00c3 C4010000 		.4byte	0x1c4
 249 00c7 07       		.uleb128 0x7
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 19


 250 00c8 15000000 		.4byte	.LASF16
 251 00cc 01       		.byte	0x1
 252 00cd F402     		.2byte	0x2f4
 253 00cf 68000000 		.4byte	0x68
 254 00d3 00000000 		.4byte	.LLST0
 255 00d7 06       		.uleb128 0x6
 256 00d8 2A000000 		.4byte	.LBB3
 257 00dc 66000000 		.4byte	.LBE3-.LBB3
 258 00e0 BA010000 		.4byte	0x1ba
 259 00e4 08       		.uleb128 0x8
 260 00e5 7200     		.ascii	"r\000"
 261 00e7 01       		.byte	0x1
 262 00e8 F702     		.2byte	0x2f7
 263 00ea 68000000 		.4byte	0x68
 264 00ee 13000000 		.4byte	.LLST1
 265 00f2 09       		.uleb128 0x9
 266 00f3 2E000000 		.4byte	.LVL5
 267 00f7 20020000 		.4byte	0x220
 268 00fb 0A       		.uleb128 0xa
 269 00fc 4A000000 		.4byte	.LVL8
 270 0100 2B020000 		.4byte	0x22b
 271 0104 1C010000 		.4byte	0x11c
 272 0108 0B       		.uleb128 0xb
 273 0109 01       		.uleb128 0x1
 274 010a 50       		.byte	0x50
 275 010b 02       		.uleb128 0x2
 276 010c 08       		.byte	0x8
 277 010d 32       		.byte	0x32
 278 010e 0B       		.uleb128 0xb
 279 010f 01       		.uleb128 0x1
 280 0110 51       		.byte	0x51
 281 0111 02       		.uleb128 0x2
 282 0112 09       		.byte	0x9
 283 0113 C8       		.byte	0xc8
 284 0114 0B       		.uleb128 0xb
 285 0115 01       		.uleb128 0x1
 286 0116 52       		.byte	0x52
 287 0117 03       		.uleb128 0x3
 288 0118 0A       		.byte	0xa
 289 0119 F401     		.2byte	0x1f4
 290 011b 00       		.byte	0
 291 011c 0A       		.uleb128 0xa
 292 011d 50000000 		.4byte	.LVL9
 293 0121 36020000 		.4byte	0x236
 294 0125 2F010000 		.4byte	0x12f
 295 0129 0B       		.uleb128 0xb
 296 012a 01       		.uleb128 0x1
 297 012b 50       		.byte	0x50
 298 012c 01       		.uleb128 0x1
 299 012d 30       		.byte	0x30
 300 012e 00       		.byte	0
 301 012f 0A       		.uleb128 0xa
 302 0130 58000000 		.4byte	.LVL10
 303 0134 42020000 		.4byte	0x242
 304 0138 4F010000 		.4byte	0x14f
 305 013c 0B       		.uleb128 0xb
 306 013d 01       		.uleb128 0x1
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 20


 307 013e 50       		.byte	0x50
 308 013f 05       		.uleb128 0x5
 309 0140 03       		.byte	0x3
 310 0141 08000000 		.4byte	.LC1
 311 0145 0B       		.uleb128 0xb
 312 0146 01       		.uleb128 0x1
 313 0147 51       		.byte	0x51
 314 0148 05       		.uleb128 0x5
 315 0149 03       		.byte	0x3
 316 014a 00000000 		.4byte	.LC0
 317 014e 00       		.byte	0
 318 014f 0A       		.uleb128 0xa
 319 0150 66000000 		.4byte	.LVL13
 320 0154 2B020000 		.4byte	0x22b
 321 0158 70010000 		.4byte	0x170
 322 015c 0B       		.uleb128 0xb
 323 015d 01       		.uleb128 0x1
 324 015e 50       		.byte	0x50
 325 015f 02       		.uleb128 0x2
 326 0160 09       		.byte	0x9
 327 0161 C8       		.byte	0xc8
 328 0162 0B       		.uleb128 0xb
 329 0163 01       		.uleb128 0x1
 330 0164 51       		.byte	0x51
 331 0165 02       		.uleb128 0x2
 332 0166 08       		.byte	0x8
 333 0167 32       		.byte	0x32
 334 0168 0B       		.uleb128 0xb
 335 0169 01       		.uleb128 0x1
 336 016a 52       		.byte	0x52
 337 016b 03       		.uleb128 0x3
 338 016c 0A       		.byte	0xa
 339 016d F401     		.2byte	0x1f4
 340 016f 00       		.byte	0
 341 0170 0A       		.uleb128 0xa
 342 0171 6C000000 		.4byte	.LVL14
 343 0175 36020000 		.4byte	0x236
 344 0179 83010000 		.4byte	0x183
 345 017d 0B       		.uleb128 0xb
 346 017e 01       		.uleb128 0x1
 347 017f 50       		.byte	0x50
 348 0180 01       		.uleb128 0x1
 349 0181 30       		.byte	0x30
 350 0182 00       		.byte	0
 351 0183 0A       		.uleb128 0xa
 352 0184 74000000 		.4byte	.LVL15
 353 0188 42020000 		.4byte	0x242
 354 018c A3010000 		.4byte	0x1a3
 355 0190 0B       		.uleb128 0xb
 356 0191 01       		.uleb128 0x1
 357 0192 50       		.byte	0x50
 358 0193 05       		.uleb128 0x5
 359 0194 03       		.byte	0x3
 360 0195 08000000 		.4byte	.LC1
 361 0199 0B       		.uleb128 0xb
 362 019a 01       		.uleb128 0x1
 363 019b 51       		.byte	0x51
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 21


 364 019c 05       		.uleb128 0x5
 365 019d 03       		.byte	0x3
 366 019e 18000000 		.4byte	.LC2
 367 01a2 00       		.byte	0
 368 01a3 0C       		.uleb128 0xc
 369 01a4 7C000000 		.4byte	.LVL16
 370 01a8 4D020000 		.4byte	0x24d
 371 01ac 0B       		.uleb128 0xb
 372 01ad 01       		.uleb128 0x1
 373 01ae 50       		.byte	0x50
 374 01af 02       		.uleb128 0x2
 375 01b0 08       		.byte	0x8
 376 01b1 64       		.byte	0x64
 377 01b2 0B       		.uleb128 0xb
 378 01b3 01       		.uleb128 0x1
 379 01b4 51       		.byte	0x51
 380 01b5 02       		.uleb128 0x2
 381 01b6 08       		.byte	0x8
 382 01b7 64       		.byte	0x64
 383 01b8 00       		.byte	0
 384 01b9 00       		.byte	0
 385 01ba 09       		.uleb128 0x9
 386 01bb 22000000 		.4byte	.LVL4
 387 01bf 58020000 		.4byte	0x258
 388 01c3 00       		.byte	0
 389 01c4 09       		.uleb128 0x9
 390 01c5 06000000 		.4byte	.LVL0
 391 01c9 63020000 		.4byte	0x263
 392 01cd 0A       		.uleb128 0xa
 393 01ce 0E000000 		.4byte	.LVL1
 394 01d2 6E020000 		.4byte	0x26e
 395 01d6 E5010000 		.4byte	0x1e5
 396 01da 0B       		.uleb128 0xb
 397 01db 01       		.uleb128 0x1
 398 01dc 50       		.byte	0x50
 399 01dd 01       		.uleb128 0x1
 400 01de 30       		.byte	0x30
 401 01df 0B       		.uleb128 0xb
 402 01e0 01       		.uleb128 0x1
 403 01e1 51       		.byte	0x51
 404 01e2 01       		.uleb128 0x1
 405 01e3 30       		.byte	0x30
 406 01e4 00       		.byte	0
 407 01e5 0A       		.uleb128 0xa
 408 01e6 16000000 		.4byte	.LVL2
 409 01ea 4D020000 		.4byte	0x24d
 410 01ee FD010000 		.4byte	0x1fd
 411 01f2 0B       		.uleb128 0xb
 412 01f3 01       		.uleb128 0x1
 413 01f4 50       		.byte	0x50
 414 01f5 01       		.uleb128 0x1
 415 01f6 30       		.byte	0x30
 416 01f7 0B       		.uleb128 0xb
 417 01f8 01       		.uleb128 0x1
 418 01f9 51       		.byte	0x51
 419 01fa 01       		.uleb128 0x1
 420 01fb 30       		.byte	0x30
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 22


 421 01fc 00       		.byte	0
 422 01fd 0C       		.uleb128 0xc
 423 01fe 1E000000 		.4byte	.LVL3
 424 0202 36020000 		.4byte	0x236
 425 0206 0B       		.uleb128 0xb
 426 0207 01       		.uleb128 0x1
 427 0208 50       		.byte	0x50
 428 0209 03       		.uleb128 0x3
 429 020a 0A       		.byte	0xa
 430 020b B80B     		.2byte	0xbb8
 431 020d 00       		.byte	0
 432 020e 00       		.byte	0
 433 020f 0D       		.uleb128 0xd
 434 0210 F1000000 		.4byte	.LASF29
 435 0214 09       		.byte	0x9
 436 0215 1207     		.2byte	0x712
 437 0217 1B020000 		.4byte	0x21b
 438 021b 0E       		.uleb128 0xe
 439 021c 76000000 		.4byte	0x76
 440 0220 0F       		.uleb128 0xf
 441 0221 15020000 		.4byte	.LASF17
 442 0225 15020000 		.4byte	.LASF17
 443 0229 04       		.byte	0x4
 444 022a 88       		.byte	0x88
 445 022b 0F       		.uleb128 0xf
 446 022c F8010000 		.4byte	.LASF18
 447 0230 F8010000 		.4byte	.LASF18
 448 0234 05       		.byte	0x5
 449 0235 12       		.byte	0x12
 450 0236 10       		.uleb128 0x10
 451 0237 E1010000 		.4byte	.LASF19
 452 023b E1010000 		.4byte	.LASF19
 453 023f 06       		.byte	0x6
 454 0240 ED02     		.2byte	0x2ed
 455 0242 0F       		.uleb128 0xf
 456 0243 0A000000 		.4byte	.LASF20
 457 0247 0A000000 		.4byte	.LASF20
 458 024b 07       		.byte	0x7
 459 024c 07       		.byte	0x7
 460 024d 0F       		.uleb128 0xf
 461 024e FE000000 		.4byte	.LASF21
 462 0252 FE000000 		.4byte	.LASF21
 463 0256 05       		.byte	0x5
 464 0257 0F       		.byte	0xf
 465 0258 0F       		.uleb128 0xf
 466 0259 03020000 		.4byte	.LASF22
 467 025d 03020000 		.4byte	.LASF22
 468 0261 08       		.byte	0x8
 469 0262 0D       		.byte	0xd
 470 0263 0F       		.uleb128 0xf
 471 0264 13010000 		.4byte	.LASF23
 472 0268 13010000 		.4byte	.LASF23
 473 026c 08       		.byte	0x8
 474 026d 0A       		.byte	0xa
 475 026e 0F       		.uleb128 0xf
 476 026f 49010000 		.4byte	.LASF24
 477 0273 49010000 		.4byte	.LASF24
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 23


 478 0277 05       		.byte	0x5
 479 0278 0B       		.byte	0xb
 480 0279 00       		.byte	0
 481              		.section	.debug_abbrev,"",%progbits
 482              	.Ldebug_abbrev0:
 483 0000 01       		.uleb128 0x1
 484 0001 11       		.uleb128 0x11
 485 0002 01       		.byte	0x1
 486 0003 25       		.uleb128 0x25
 487 0004 0E       		.uleb128 0xe
 488 0005 13       		.uleb128 0x13
 489 0006 0B       		.uleb128 0xb
 490 0007 03       		.uleb128 0x3
 491 0008 0E       		.uleb128 0xe
 492 0009 1B       		.uleb128 0x1b
 493 000a 0E       		.uleb128 0xe
 494 000b 55       		.uleb128 0x55
 495 000c 17       		.uleb128 0x17
 496 000d 11       		.uleb128 0x11
 497 000e 01       		.uleb128 0x1
 498 000f 10       		.uleb128 0x10
 499 0010 17       		.uleb128 0x17
 500 0011 00       		.byte	0
 501 0012 00       		.byte	0
 502 0013 02       		.uleb128 0x2
 503 0014 24       		.uleb128 0x24
 504 0015 00       		.byte	0
 505 0016 0B       		.uleb128 0xb
 506 0017 0B       		.uleb128 0xb
 507 0018 3E       		.uleb128 0x3e
 508 0019 0B       		.uleb128 0xb
 509 001a 03       		.uleb128 0x3
 510 001b 0E       		.uleb128 0xe
 511 001c 00       		.byte	0
 512 001d 00       		.byte	0
 513 001e 03       		.uleb128 0x3
 514 001f 16       		.uleb128 0x16
 515 0020 00       		.byte	0
 516 0021 03       		.uleb128 0x3
 517 0022 0E       		.uleb128 0xe
 518 0023 3A       		.uleb128 0x3a
 519 0024 0B       		.uleb128 0xb
 520 0025 3B       		.uleb128 0x3b
 521 0026 0B       		.uleb128 0xb
 522 0027 49       		.uleb128 0x49
 523 0028 13       		.uleb128 0x13
 524 0029 00       		.byte	0
 525 002a 00       		.byte	0
 526 002b 04       		.uleb128 0x4
 527 002c 24       		.uleb128 0x24
 528 002d 00       		.byte	0
 529 002e 0B       		.uleb128 0xb
 530 002f 0B       		.uleb128 0xb
 531 0030 3E       		.uleb128 0x3e
 532 0031 0B       		.uleb128 0xb
 533 0032 03       		.uleb128 0x3
 534 0033 08       		.uleb128 0x8
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 24


 535 0034 00       		.byte	0
 536 0035 00       		.byte	0
 537 0036 05       		.uleb128 0x5
 538 0037 2E       		.uleb128 0x2e
 539 0038 01       		.byte	0x1
 540 0039 3F       		.uleb128 0x3f
 541 003a 19       		.uleb128 0x19
 542 003b 03       		.uleb128 0x3
 543 003c 0E       		.uleb128 0xe
 544 003d 3A       		.uleb128 0x3a
 545 003e 0B       		.uleb128 0xb
 546 003f 3B       		.uleb128 0x3b
 547 0040 05       		.uleb128 0x5
 548 0041 27       		.uleb128 0x27
 549 0042 19       		.uleb128 0x19
 550 0043 8701     		.uleb128 0x87
 551 0045 19       		.uleb128 0x19
 552 0046 11       		.uleb128 0x11
 553 0047 01       		.uleb128 0x1
 554 0048 12       		.uleb128 0x12
 555 0049 06       		.uleb128 0x6
 556 004a 40       		.uleb128 0x40
 557 004b 18       		.uleb128 0x18
 558 004c 9742     		.uleb128 0x2117
 559 004e 19       		.uleb128 0x19
 560 004f 01       		.uleb128 0x1
 561 0050 13       		.uleb128 0x13
 562 0051 00       		.byte	0
 563 0052 00       		.byte	0
 564 0053 06       		.uleb128 0x6
 565 0054 0B       		.uleb128 0xb
 566 0055 01       		.byte	0x1
 567 0056 11       		.uleb128 0x11
 568 0057 01       		.uleb128 0x1
 569 0058 12       		.uleb128 0x12
 570 0059 06       		.uleb128 0x6
 571 005a 01       		.uleb128 0x1
 572 005b 13       		.uleb128 0x13
 573 005c 00       		.byte	0
 574 005d 00       		.byte	0
 575 005e 07       		.uleb128 0x7
 576 005f 34       		.uleb128 0x34
 577 0060 00       		.byte	0
 578 0061 03       		.uleb128 0x3
 579 0062 0E       		.uleb128 0xe
 580 0063 3A       		.uleb128 0x3a
 581 0064 0B       		.uleb128 0xb
 582 0065 3B       		.uleb128 0x3b
 583 0066 05       		.uleb128 0x5
 584 0067 49       		.uleb128 0x49
 585 0068 13       		.uleb128 0x13
 586 0069 02       		.uleb128 0x2
 587 006a 17       		.uleb128 0x17
 588 006b 00       		.byte	0
 589 006c 00       		.byte	0
 590 006d 08       		.uleb128 0x8
 591 006e 34       		.uleb128 0x34
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 25


 592 006f 00       		.byte	0
 593 0070 03       		.uleb128 0x3
 594 0071 08       		.uleb128 0x8
 595 0072 3A       		.uleb128 0x3a
 596 0073 0B       		.uleb128 0xb
 597 0074 3B       		.uleb128 0x3b
 598 0075 05       		.uleb128 0x5
 599 0076 49       		.uleb128 0x49
 600 0077 13       		.uleb128 0x13
 601 0078 02       		.uleb128 0x2
 602 0079 17       		.uleb128 0x17
 603 007a 00       		.byte	0
 604 007b 00       		.byte	0
 605 007c 09       		.uleb128 0x9
 606 007d 898201   		.uleb128 0x4109
 607 0080 00       		.byte	0
 608 0081 11       		.uleb128 0x11
 609 0082 01       		.uleb128 0x1
 610 0083 31       		.uleb128 0x31
 611 0084 13       		.uleb128 0x13
 612 0085 00       		.byte	0
 613 0086 00       		.byte	0
 614 0087 0A       		.uleb128 0xa
 615 0088 898201   		.uleb128 0x4109
 616 008b 01       		.byte	0x1
 617 008c 11       		.uleb128 0x11
 618 008d 01       		.uleb128 0x1
 619 008e 31       		.uleb128 0x31
 620 008f 13       		.uleb128 0x13
 621 0090 01       		.uleb128 0x1
 622 0091 13       		.uleb128 0x13
 623 0092 00       		.byte	0
 624 0093 00       		.byte	0
 625 0094 0B       		.uleb128 0xb
 626 0095 8A8201   		.uleb128 0x410a
 627 0098 00       		.byte	0
 628 0099 02       		.uleb128 0x2
 629 009a 18       		.uleb128 0x18
 630 009b 9142     		.uleb128 0x2111
 631 009d 18       		.uleb128 0x18
 632 009e 00       		.byte	0
 633 009f 00       		.byte	0
 634 00a0 0C       		.uleb128 0xc
 635 00a1 898201   		.uleb128 0x4109
 636 00a4 01       		.byte	0x1
 637 00a5 11       		.uleb128 0x11
 638 00a6 01       		.uleb128 0x1
 639 00a7 31       		.uleb128 0x31
 640 00a8 13       		.uleb128 0x13
 641 00a9 00       		.byte	0
 642 00aa 00       		.byte	0
 643 00ab 0D       		.uleb128 0xd
 644 00ac 34       		.uleb128 0x34
 645 00ad 00       		.byte	0
 646 00ae 03       		.uleb128 0x3
 647 00af 0E       		.uleb128 0xe
 648 00b0 3A       		.uleb128 0x3a
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 26


 649 00b1 0B       		.uleb128 0xb
 650 00b2 3B       		.uleb128 0x3b
 651 00b3 05       		.uleb128 0x5
 652 00b4 49       		.uleb128 0x49
 653 00b5 13       		.uleb128 0x13
 654 00b6 3F       		.uleb128 0x3f
 655 00b7 19       		.uleb128 0x19
 656 00b8 3C       		.uleb128 0x3c
 657 00b9 19       		.uleb128 0x19
 658 00ba 00       		.byte	0
 659 00bb 00       		.byte	0
 660 00bc 0E       		.uleb128 0xe
 661 00bd 35       		.uleb128 0x35
 662 00be 00       		.byte	0
 663 00bf 49       		.uleb128 0x49
 664 00c0 13       		.uleb128 0x13
 665 00c1 00       		.byte	0
 666 00c2 00       		.byte	0
 667 00c3 0F       		.uleb128 0xf
 668 00c4 2E       		.uleb128 0x2e
 669 00c5 00       		.byte	0
 670 00c6 3F       		.uleb128 0x3f
 671 00c7 19       		.uleb128 0x19
 672 00c8 3C       		.uleb128 0x3c
 673 00c9 19       		.uleb128 0x19
 674 00ca 6E       		.uleb128 0x6e
 675 00cb 0E       		.uleb128 0xe
 676 00cc 03       		.uleb128 0x3
 677 00cd 0E       		.uleb128 0xe
 678 00ce 3A       		.uleb128 0x3a
 679 00cf 0B       		.uleb128 0xb
 680 00d0 3B       		.uleb128 0x3b
 681 00d1 0B       		.uleb128 0xb
 682 00d2 00       		.byte	0
 683 00d3 00       		.byte	0
 684 00d4 10       		.uleb128 0x10
 685 00d5 2E       		.uleb128 0x2e
 686 00d6 00       		.byte	0
 687 00d7 3F       		.uleb128 0x3f
 688 00d8 19       		.uleb128 0x19
 689 00d9 3C       		.uleb128 0x3c
 690 00da 19       		.uleb128 0x19
 691 00db 6E       		.uleb128 0x6e
 692 00dc 0E       		.uleb128 0xe
 693 00dd 03       		.uleb128 0x3
 694 00de 0E       		.uleb128 0xe
 695 00df 3A       		.uleb128 0x3a
 696 00e0 0B       		.uleb128 0xb
 697 00e1 3B       		.uleb128 0x3b
 698 00e2 05       		.uleb128 0x5
 699 00e3 00       		.byte	0
 700 00e4 00       		.byte	0
 701 00e5 00       		.byte	0
 702              		.section	.debug_loc,"",%progbits
 703              	.Ldebug_loc0:
 704              	.LLST0:
 705 0000 22000000 		.4byte	.LVL4
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 27


 706 0004 2D000000 		.4byte	.LVL5-1
 707 0008 0100     		.2byte	0x1
 708 000a 50       		.byte	0x50
 709 000b 00000000 		.4byte	0
 710 000f 00000000 		.4byte	0
 711              	.LLST1:
 712 0013 3C000000 		.4byte	.LVL6
 713 0017 46000000 		.4byte	.LVL7
 714 001b 0100     		.2byte	0x1
 715 001d 50       		.byte	0x50
 716 001e 5A000000 		.4byte	.LVL11
 717 0022 62000000 		.4byte	.LVL12
 718 0026 0100     		.2byte	0x1
 719 0028 50       		.byte	0x50
 720 0029 00000000 		.4byte	0
 721 002d 00000000 		.4byte	0
 722              		.section	.debug_aranges,"",%progbits
 723 0000 1C000000 		.4byte	0x1c
 724 0004 0200     		.2byte	0x2
 725 0006 00000000 		.4byte	.Ldebug_info0
 726 000a 04       		.byte	0x4
 727 000b 00       		.byte	0
 728 000c 0000     		.2byte	0
 729 000e 0000     		.2byte	0
 730 0010 00000000 		.4byte	.LFB85
 731 0014 90000000 		.4byte	.LFE85-.LFB85
 732 0018 00000000 		.4byte	0
 733 001c 00000000 		.4byte	0
 734              		.section	.debug_ranges,"",%progbits
 735              	.Ldebug_ranges0:
 736 0000 00000000 		.4byte	.LFB85
 737 0004 90000000 		.4byte	.LFE85
 738 0008 00000000 		.4byte	0
 739 000c 00000000 		.4byte	0
 740              		.section	.debug_line,"",%progbits
 741              	.Ldebug_line0:
 742 0000 39020000 		.section	.debug_str,"MS",%progbits,1
 742      02000D02 
 742      00000201 
 742      FB0E0D00 
 742      01010101 
 743              	.LASF9:
 744 0000 5F5F696E 		.ascii	"__int32_t\000"
 744      7433325F 
 744      7400
 745              	.LASF20:
 746 000a 7072696E 		.ascii	"print_mqtt\000"
 746      745F6D71 
 746      747400
 747              	.LASF16:
 748 0015 64697374 		.ascii	"distance\000"
 748      616E6365 
 748      00
 749              	.LASF11:
 750 001e 666C6F61 		.ascii	"float\000"
 750      7400
 751              	.LASF0:
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 28


 752 0024 7369676E 		.ascii	"signed char\000"
 752      65642063 
 752      68617200 
 753              	.LASF1:
 754 0030 756E7369 		.ascii	"unsigned char\000"
 754      676E6564 
 754      20636861 
 754      7200
 755              	.LASF25:
 756 003e 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 756      43313120 
 756      352E342E 
 756      31203230 
 756      31363036 
 757 0071 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 757      20726576 
 757      6973696F 
 757      6E203233 
 757      37373135 
 758 00a4 67202D66 		.ascii	"g -ffunction-sections -ffat-lto-objects\000"
 758      66756E63 
 758      74696F6E 
 758      2D736563 
 758      74696F6E 
 759              	.LASF5:
 760 00cc 6C6F6E67 		.ascii	"long unsigned int\000"
 760      20756E73 
 760      69676E65 
 760      6420696E 
 760      7400
 761              	.LASF3:
 762 00de 73686F72 		.ascii	"short unsigned int\000"
 762      7420756E 
 762      7369676E 
 762      65642069 
 762      6E7400
 763              	.LASF29:
 764 00f1 49544D5F 		.ascii	"ITM_RxBuffer\000"
 764      52784275 
 764      66666572 
 764      00
 765              	.LASF21:
 766 00fe 6D6F746F 		.ascii	"motor_forward\000"
 766      725F666F 
 766      72776172 
 766      6400
 767              	.LASF12:
 768 010c 646F7562 		.ascii	"double\000"
 768      6C6500
 769              	.LASF23:
 770 0113 556C7472 		.ascii	"Ultra_Start\000"
 770      615F5374 
 770      61727400 
 771              	.LASF28:
 772 011f 7A6D6169 		.ascii	"zmain\000"
 772      6E00
 773              	.LASF8:
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 29


 774 0125 756E7369 		.ascii	"unsigned int\000"
 774      676E6564 
 774      20696E74 
 774      00
 775              	.LASF7:
 776 0132 6C6F6E67 		.ascii	"long long unsigned int\000"
 776      206C6F6E 
 776      6720756E 
 776      7369676E 
 776      65642069 
 777              	.LASF24:
 778 0149 6D6F746F 		.ascii	"motor_start\000"
 778      725F7374 
 778      61727400 
 779              	.LASF10:
 780 0155 696E7433 		.ascii	"int32_t\000"
 780      325F7400 
 781              	.LASF27:
 782 015d 433A5C55 		.ascii	"C:\\Users\\ilyap\\Documents\\PSoC Creator\\Zumo_tan"
 782      73657273 
 782      5C696C79 
 782      61705C44 
 782      6F63756D 
 783 018b 6B5C5A75 		.ascii	"k\\Zumo_robot\\ZumoBot_Tank.cydsn\000"
 783      6D6F5F72 
 783      6F626F74 
 783      5C5A756D 
 783      6F426F74 
 784              	.LASF15:
 785 01ab 73697A65 		.ascii	"sizetype\000"
 785      74797065 
 785      00
 786              	.LASF6:
 787 01b4 6C6F6E67 		.ascii	"long long int\000"
 787      206C6F6E 
 787      6720696E 
 787      7400
 788              	.LASF26:
 789 01c2 6D61696E 		.ascii	"main.c\000"
 789      2E6300
 790              	.LASF13:
 791 01c9 63686172 		.ascii	"char\000"
 791      00
 792              	.LASF2:
 793 01ce 73686F72 		.ascii	"short int\000"
 793      7420696E 
 793      7400
 794              	.LASF4:
 795 01d8 6C6F6E67 		.ascii	"long int\000"
 795      20696E74 
 795      00
 796              	.LASF19:
 797 01e1 76546173 		.ascii	"vTaskDelay\000"
 797      6B44656C 
 797      617900
 798              	.LASF14:
 799 01ec 6C6F6E67 		.ascii	"long double\000"
ARM GAS  C:\Users\ilyap\AppData\Local\Temp\ccbKPUml.s 			page 30


 799      20646F75 
 799      626C6500 
 800              	.LASF18:
 801 01f8 6D6F746F 		.ascii	"motor_turn\000"
 801      725F7475 
 801      726E00
 802              	.LASF22:
 803 0203 556C7472 		.ascii	"Ultra_GetDistance\000"
 803      615F4765 
 803      74446973 
 803      74616E63 
 803      6500
 804              	.LASF17:
 805 0215 72616E64 		.ascii	"rand\000"
 805      00
 806              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
